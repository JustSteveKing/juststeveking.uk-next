<!DOCTYPE html>
<html lang="en" class="no-js">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
        <title>Building a REST API in GoLang - Part 1</title>

        <script type="module">
            document.documentElement.classList.remove('no-js');
            document.documentElement.classList.add('js');
        </script>

        <link href="https://fonts.googleapis.com/css?family=Nunito+Sans:300,300i,400,400i,700,700i,800,800i,900,900i" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Poppins:300,300i,400,400i,700,700i,800,800i,900,900i" rel="stylesheet">
        <link rel="stylesheet" href="/assets/build/css/main.css?id=97d16da7b8a7104e6fd6">

        <meta name="description" content="I have been building APIs for production environments for many years now, predominently in PHP. The last 3 years however, I have been hard at work getting to grips with GoLang - so I thought I would change the pace and share a post on GoLang">

        <meta property="og:title" content="Building a REST API in GoLang - Part 1">
        <meta property="og:description" content="I have been building APIs for production environments for many years now, predominently in PHP. The last 3 years however, I have been hard at work getting to grips with GoLang - so I thought I would change the pace and share a post on GoLang">
        <meta property="og:image" content="/assets/images/uploads/go-lang.png">
        <meta property="og:image:alt" content="JustSteveKing - Consultant CTO, Freelance Software Engineer, Community Advocate">
        <meta property="og:locale" content="en_GB">
        <meta property="og:type" content="article">
        <meta proporty="og:url" content="https://www.juststeveking.uk/building-a-rest-api-in-golang-part-1">

        <meta name="twitter:widgets:new-embed-design" content="on">
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Building a REST API in GoLang - Part 1">
        <meta name="twitter:description" content="I have been building APIs for production environments for many years now, predominently in PHP. The last 3 years however, I have been hard at work getting to grips with GoLang - so I thought I would change the pace and share a post on GoLang">
        <meta name="twitter:site" content="@JustSteveKing">
        <meta name="twitter:creator" content="@JustSteveKing">
        <meta name="twitter:image" content="/assets/images/uploads/go-lang.png">
        <meta name="twitter:image:alt" content="JustSteveKing - Consultant CTO, Freelance Software Engineer, Community Advocate">

        <link rel="canonical" href="https://www.juststeveking.uk/building-a-rest-api-in-golang-part-1">
        <link rel="alternate" type="application/rss+xml" title="Building a REST API in GoLang - Part 1" href="https://www.juststeveking.uk//feed.xml" />

        <!-- PHPOnline Domain Verification -->
        <meta name="phponline:verification" content="phponline:e1wmN0TcK4gr" />

        <link rel="icon" href="/assets/favicon.ico">
        <link rel="icon" href="/assets/favicon.svg" type="image/svg+xml">
        <link rel="apple-touch-icon" href="/assets/favicon.png">
        <link rel="manifest" href="/assets/site.webmanifest">
        <meta name="theme-color" content="#ffffff">
        
        <script src="/assets/build/js/main.js?id=3adf2f0e4ec657222174" defer></script>
        
        <script type="application/ld+json">
        {
            "@content": "https://schema.org/",
            "@type": "Person",
            "name": "Steve McDougall",
            "url": "https://www.juststeveking.uk/",
            "image": "https://www.juststeveking.uk/images/avatar.png",
            "sameAs": [
                "https://github.com/JustSteveKing",
                "https://twitter.com/JustSteveKing",
                "https://www.linkedin.com/in/steve-mcdougall/"
            ],
            "jobTitle": "Technical Lead",
            "worksFor": {
                "@type": "Organization",
                "name": "Squarefoot Capital Limited",
                "url": "https://sqft.capital",
                "foundingDate": "2019-10-10",
                "sameAs": [
                    "https://www.linkedin.com/company/squarefootcapital/"
                ],
                "description": "sqft.capital is a platform solely for UK property developers to model deals and raise funding, quickly and consistently." 
            }
        }
        </script>

                    <!-- Fathom - beautiful, simple website analytics -->
            <script
                src="https://cdn.usefathom.com/script.js"
                data-site="SGJKEWOR"
                defer
            ></script>
            <!-- / Fathom -->
            </head>
    <body class="antialiased bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-50">
         <nav class="container mx-auto py-12">
    <ul class="flex items-center justify-center space-x-6 uppercase">
                    <li>
                 <a
    class="cursor-pointer text-gray-600 dark:text-gray-200 hover:text-gray-800 dark:hover:text-gray-50" title="Return Home" href="/"
    title="Return Home" href="/"
>
    Home
</a> 
            </li>
                    <li>
                 <a
    class="cursor-pointer text-gray-600 dark:text-gray-200 hover:text-gray-800 dark:hover:text-gray-50" title="Recent Articles" href="/blog"
    title="Recent Articles" href="/blog"
>
    Articles
</a> 
            </li>
                    <li>
                 <a
    class="cursor-pointer text-gray-600 dark:text-gray-200 hover:text-gray-800 dark:hover:text-gray-50" title="Open Source packages I have made" href="/open-source"
    title="Open Source packages I have made" href="/open-source"
>
    Open Source
</a> 
            </li>
                    <li>
                 <a
    class="cursor-pointer text-gray-600 dark:text-gray-200 hover:text-gray-800 dark:hover:text-gray-50" title="Subscribe to my RSS feed" href="/feed.xml"
    title="Subscribe to my RSS feed" href="/feed.xml"
>
    RSS Feed
</a> 
            </li>
            </ul>
</nav> 
        
            <main class="max-w-3xl mx-auto px-4 sm:px-6 xl:max-w-5xl xl:px-0">
        <article class="xl:divide-y xl:divide-gray-200">
            <header class="pt-6 xl:pb-10">
                <div class="space-y-1 text-center">
                    <dl class="space-y-10">
                        <div>
                            <dt class="sr-only">
                                Published on
                            </dt>
                            <dd class="text-base leading-6 font-medium">
                                <time datetime="2020-07-24">
                                    Friday, 24th July 2020
                                </time>
                            </dd>
                        </div>
                    </dl>
                    <div>
                        <h1 class="text-3xl leading-9 font-extrabold tracking-wider sm:text-4xl sm:leading-10 md:text-5xl md:leading-14">
                            Building a REST API in GoLang - Part 1
                        </h1>
                    </div>
                </div>
            </header>

        <div class="divide-y xl:divide-y-0 divide-gray-200 xl:grid xl:grid-cols-4 xl:col-gap-6 pb-16 xl:pb-20" style="grid-template-rows: auto 1fr;">
            <dl class="pt-6 pb-10 xl:pt-11 xl:border-b xl:border-gray-200">
                <dt class="sr-only">Authors</dt>
                <dd>
                    <ul class="flex justify-center xl:block space-x-8 sm:space-x-12 xl:space-x-0 xl:space-y-8">
                        <li class="flex items-center space-x-2">
                             <img
    src="/assets/images/avatar.png"
    alt="Steve McDougall Avatar"
    class="object-fit object-center rounded-full w-10 h-10"
/> 
                            <dl class="text-sm font-medium leading-5 whitespace-no-wrap">
                                <dt class="sr-only">Name</dt>
                                <dd>Steve McDougall</dd>
                                <dt class="sr-only">Twitter</dt>
                                <dd>
                                     <a
    class="cursor-pointer text-gray-600 dark:text-gray-200 hover:text-gray-800 dark:hover:text-gray-50" href="https://twitter.com/JustSteveKing" target="__blank" rel="noopener nofollow" title="Follow Steve on twitter"
    href="https://twitter.com/JustSteveKing" target="__blank" rel="noopener nofollow" title="Follow Steve on twitter"
>
    @JustSteveKing
</a> 
                                </dd>
                            </dl>
                        </li>
                    </ul>
                </dd>
            </dl>
            <div class="divide-y divide-gray-200 xl:pb-0 xl:col-span-3 xl:row-span-2">
                <div class="prose prose-indigo prose-lg text-gray-800 dark:text-gray-50 pt-10 pb-8 px-3">
                    <img src="/assets/images/uploads/go-lang.png"
                        alt="Building a REST API in GoLang - Part 1"
                        class="rounded shadow-md"
                    />
                    <p>I have been building APIs for production environments for many years now,
predominently in PHP. The last 3 years however, I have been hard at work
getting to grips with GoLang - so I thought I would change the pace and share
a post on GoLang.</p>

<p>For the past 4 weeks I have been using GoLang as my primary language with one of my clients, after an initial consultation on their requirements and talking about where they were seeing botlenecks in their business - some modernisation was needed. I initially went through an Event Storming session to see the sort of business events that were common in their business, to see if it would highlight any additional (hidden) issues. After a successful session it was clear that their systems were no cohesive enough, and speed was a major issue. This seemed like a perfect opportunity to use GoLang to help solve their problems.</p>

<p>This post will walk through an approach I have taken to build a REST API in GoLang, and why I do things a certain way. I am not saying this is <em>the</em> way to build REST APIs in the language, but coming from other languages this way made the most sense after some trial and error. For the purpose of being to the point, I will not be following how I would usually build an API. I would usually take the Design first API approach - using openapi specifications to design my API before writting code, and I also will not be writting tests because there are 100s of examples of writting tests out there. This is a concise post about how I go about building APIs in GoLang.</p>

<p>My first step in any API build, is to create a Docker container to run my API on. I love docker for many reasons, but that is another blog post. When building docker containers I tend to stick to the rule of one service per container - meaning if you have a cache layer, database layer, and an application layer you should have 3 containers running together. Here is the base <strong>Dockerfile</strong> that I use for my GoLang service:</p>

<pre><code class="language-dockerfile"># Create our container from a very lightweight image
FROM golang:alpine

# Set our working directory for the container
WORKDIR /app

# Copy our entire application into the Working Directory
COPY ./ /app

# Install our Go Modules
RUN go mod download

# Set the entry point for our application
ENTRYPOINT go run cmd/rest-api/server.go
</code></pre>

<p>What we have here is a nice lightweight GoLang container for us to inject our API into. The next step is to create our <strong>docker-compose.yml</strong> file to define our services, I prefer using the docker-compose approach while building applications. Here is an example of my docker-compose file:</p>

<pre><code class="language-yaml">version: "3"

networks:
api:

services:
go_api:
    build:
    context: .
    dockerfile: Dockerfile
    container_name: go_rest_api
    networks:
    - api
    ports:
    - 8080:8080
    volumes:
    - ./:/app
</code></pre>

<p>What we are doing here is creating a network for our REST API, creating a container and giving it a name, giving the container build instructions from our Dockerfile, and setting the container post and mounting volumes. I won't go into too much detail here, as this is a tutorial on GoLang not docker.</p>

<p>Our next step once we have docker ready to go, is to start our project with Go! My first step is to alsways start by initialising go modules:</p>

<pre><code class="language-bash">go mod init github.com/JustSteveKing/go-rest-api
</code></pre>

<p>This step sets your working directory are the root for a Go module at the specified URL. Our next step is to look at the directory structure. There are many approaches to how you could do this, a lot of developers will tell you for something simple you should just use the flat structure where everything is in one root directory. <strong>I do not like this approach</strong>. I come from other programming languages where separation of concerns is often done through namespacing and directory separation. As you can probably already guess from my Dockerfile - I have a <strong>cmd</strong> directory as my entrypoint. Let me explain.</p>

<p>A Go program needs an entry script to run, you don't want one really big file called <strong>main.go</strong> where all you application code lives - this like any other language would be difficult to manage. My approach is to have 2 root directories: <strong>cmd</strong> and <strong>pkg</strong>. My CMD directory is the entrypoint to the application, I would usually structure it using: <code>cmd/{ project-name }/server.go</code> so I have a command to run, inside of a project, which runs a server. If this was a CLI application I would change <strong>server.go</strong> to <strong>cli.go</strong> so it makes sense to any develop looking at the code.</p>

<p>Our <strong>pkg</strong> directory is where we keep all the code for this package. This is a relatively common concept in the Go world, as each application is a package. From this point, the application code lives inside pkg. Some developers will repeat the project name approach inside the pkg directory, but I am not a fan of that. I am not deploying multiple packages in this project - just the one. The same could be said for the <strong>cmd</strong> directory - but I digress. I like what I like.</p>

<p>When building my entry point code in server.go I want it to remain relatively clean. I dont't want my main running to be full of set up code and declarations! This to me doesn't feel like a good developer experience. I have used frameworks such as Laravel in the past, and my favourite thing about the framework is the attention to detail and the quality of developer experience. You can achieve a lot and the code remains clean and readable. In Go this is even more true, as you would typically build this application into an executable program for your environment.</p>

<p>Let me show you an example of my <strong>server.go</strong> file and then I can walk through what is going on:</p>

<pre><code class="language-go">// cmd/rest-api/server.go
package main

import (
    "github.com/joho/godotenv"
    "github.com/JustSteveKing/go-rest-api/pkg/infrastructure/kernel"
)

func init() {
    if err := godotenv.Load(); err != nil {
        panic("No .env file found")
    }
}

func main() {
    // Boot our application
    app := kernel.Boot()

    // Build our application services, passing in our application itself
    // We will add our services here later

    // Run our application
    go func () {
        app.Run()
    }()

    // Wait for termination signals
    app.WaitForShutdown()
}
</code></pre>

<p>So what we have here is a simple entrypoint to our application, we load out environment variables before we run the application itself - we won't want to panic and crash our application halfway through processing because we didn't load our environement. The next step is to tell our application kernal to boot, basically create all relevant services that are needed to run the application and create and return the application itself. We the start a goroutine to run our application in, so that our main thread is responsible for starting and closing our application, but we have a separate thread for our application to run in. We then tell our application to listen for any termination signals that may occur. As you can see from our import statements, we are pulling in 2 new files from our application. Our <strong>kernel</strong> and our <strong>manager</strong> - what I am doing here is separating how the application is loaded and following some relatively basic Domain Driven Design principles.</p>

<p>Our next step in building this application out is going to be creating our application kernel itself, as this is the first thing to load:</p>

<pre><code class="language-go">// pkg/infrastructure/kernel/app-kernel.go
package kernel

import (
    gohandlers "github.com/gorilla/handlers"
    "github.com/JustSteveKing/go-rest-api/pkg/infrastructure/factories"
    "github.com/JustSteveKing/go-rest-api/pkg/infrastructure/providers"
)

// Boot our application and it's services
func Boot() *factories.Application {
    // Build our configration
    config := providers.ConfigProvider()

    // Build our router
    router := providers.RouteProvider()

    // Build our application logger
    logger := providers.LoggerProvider()

    // Set up CORS protection
    corsHandler := gohandlers.CORS(gohandlers.AllowedOrigins([]string{"*"}))

    // return a built application
    return &amp;factories.Application{
        Server: &amp;http.Server{
        Addr:              ":" + config.App.Port,
        Handler:           corsHandler(router),
        ReadTimeout:       1 * time.Second,
        WriteTimeout:      1 * time.Second,
        IdleTimeout:       120 * time.Second,
        },
        Router: router,
        Logger: logger,
        Config: config,
    }
}
</code></pre>

<p>So what we are doing here is booting our application, and returning a built Application. To start with, we create our configuration, routing and logging from our service providers - which we will build shortly. We then use gorilla/mux to add CORS protection around our routing. You might ask why are we adding all of this here, but this will become clear when we start adding application services to our domain/context. One of the key things here is to add sensible defaults to our http Server itself, this could be config/environment driven if you wanted to - but these are relatively sensible defaults so I tend to hard code these.</p>

<p>Service Providers? This is a well known approach to scale in an application that uses dependency injection. I am not using DI in this example however, these providers are responsible for building and returning specific structures for our application. This could be seen as early over engineering - but it isn't many lines of code, and I like to start as I mean to go on when writting code.</p>

<p>Our configuration provider looks like this:</p>

<pre><code class="language-go">// pkg/infrastructure/providers/config-provider.go
package providers

import "github.com/JustSteveKing/go-rest-api/pkg/infrastructure/factories"

// ConfigProvider will run and create a new Config struct from the Config Factory
func ConfigProvider() *factories.Config {
    return factories.ConfigFactory()
}
</code></pre>

<p>As you can see the only job of this provider is to create our Config struct from our configuration factory. What this allows us to do, should we need to, is add extra configuratino options to inject into our factory when we are creating it. So it is flexible and extendable to a point.</p>

<p>Let's take a quick moment to look at our Config Factory to see what it is:</p>

<pre><code class="language-go">// pkg/infrastructure/factories/config-factory.go
package factories

import "os"

// AppConfig is the Application configuration struct
type AppConfig struct {
    Name    string
    Version string
    Port    string
}

// HTTPConfig is the Application HTTP configuration
type HTTPConfig struct {
    Content string
    Problem string
}

// Config is the Configuration struct
type Config struct {
    App  AppConfig
    HTTP HTTPConfig
}

// ConfigFactory returns a new Config Struct
func ConfigFactory() *Config {
    return &amp;Config{
        App: AppConfig{
            Name:    env("APP_NAME", "Go App"),
            Version: env("APP_VERSION", "v1.0"),
            Port:    env("APP_PORT", ":8080"),
        },
        HTTP: HTTPConfig{
            Content: env("HTTP_CONTENT_TYPE", "application/json"),
            Problem: env("HTTP_PROBLEM", "application/problem+json"),
        },
    }
}

// env is a simple helper function to read an environment variable or return a default value
func env(key string, defaultValue string) string {
    if value, exists := os.LookupEnv(key); exists {
        return value
    }

    return defaultValue
}
</code></pre>

<p>This is a simple struct building factory, which will give us our applications configuration, it also has the helper functino <strong>env</strong> for nicer loading and providing a default when there isn't an entry in our <strong>env</strong> file - this was inspired by Laravel.</p>

<p>Back to the application. We have seen how we use providers, and how our factories work and why. This is basically just a nice way to work. Eventually I would like to move some of this basic code out of the project and into go modules that I can centrally manage and pull into applications when I need them. But that is a task for another day.</p>

<p>Moving back to our Application and the application factory we have seen mentioned. This is a simple and easy way to build the application we want to be running:</p>

<pre><code class="language-go">// pkg/infrastructure/factories/application-factory.go
package factories

import (
    "context"
    "github.com/gorilla/mux"
    "go.uber.org/zap"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

// Application is out general purpose Application struct which contains a link through to the main services connected
type Application struct {
    Server *http.Server
    Router *mux.Router
    Logger *zap.Logger
    Config *Config
}

// Run will start the application as required
func (app *Application) Run() {
    err := app.Server.ListenAndServe()

    if err != nil {
        panic(err)
    }
}

// WaitForShutdown is a graceful way to handle server shutdown events
func (app *Application) WaitForShutdown() {
    // Create a channel to listen for OS signals
    interruptChan := make(chan os.Signal, 1)
    signal.Notify(interruptChan, os.Interrupt, os.Kill, syscall.SIGINT, syscall.SIGTERM)

    // Block until we receive a signal to our channel
    &lt;-interruptChan

    app.Logger.Info("Received shutdown signal, gracefully terminating")

    ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
    defer cancel()
    app.Server.Shutdown(ctx)
    os.Exit(0)
}
</code></pre>

<p>So to start with, we define a struct for our application, what do we want our application to be built with? What are the core components in the Application itself outside our domain code. We need a server, a router, a logger and some configuration. So back in our kernel we saw that we run this application. This simple tells our configured application server to listen and serve. We then wait to see if this returns an error for any reason, and if it does - we panic with the error.  This is to code that we run in our goroutine, on the separate thread.</p>

<p>The next thing you will notice is the WaitForShutdown function, which is a graceful way of listening for any interuption signals, and then we can close the application down and exit out program. This code was something that I was advised on by several other developers. I wondered if there was an efficient and "nice" way to exit a program, and this is the end result. I cannot take full credit for this beautiful looking code.</p>

<p>So we have the basics. We have something that will run in our Docker container and listen on a port. The next step is to start looking at our actual application code, not the set up. This could have been majorly simplified to a few functions in a main.go file, but then it would be scalable and we would be blurring the boundaries between infrastructure/application and domain - which is always messy as more hands work on a single code base.</p>

<p>So previously we saw in out server command that we would be adding things to it. The approach I take, is to have basic setup of the application and then service registration in the command itself. After playing with several approaches this is the one that made the most sense to me. This may not work for everyone, but I found it is a nice way to manage features inside an API and from asingle glance you can see what is going on.</p>

<p>So let's take a look at the server.go file again, and see it in a more full form:</p>

<pre><code class="language-go">// cmd/rest-api/server.go
package main

import (
    "github.com/joho/godotenv"
    "github.com/JustSteveKing/go-rest-api/pkg/application/manager"
    "github.com/JustSteveKing/go-rest-api/pkg/infrastructure/kernel"
)

func init() {
    if err := godotenv.Load(); err != nil {
        panic("No .env file found")
    }
}

func main() {
    app := kernel.Boot()

    // Specific Application Services
    manager.BootPingService(app)
    manager.BootUserServce(app)

    go func() {
        app.Run()
    }()

    app.WaitForShutdown()
}
</code></pre>

<p>So you can see the new additions of <strong>manager.Boot - something - Service(app)</strong> which is how I do my service registration. For each context/domain I create a new method inside the application manager to boot this service and pass through anything that may be needed.</p>

<p>Let's take a look at one of these Service managers and I will explain what is happening.</p>

<pre><code class="language-go">// pkg/application/manager/ping-service.go
package manager

import(
    "github.com/JustSteveKing/go-rest-api/pkg/domain/ping"
)

// BootPingService is responsible for setting up all the dependencies for ping
func BootPingService(app *factories.Application) {
    // Create a new Ping Service
    service := ping.NewService(app)

    // Create a new http.Handler
    handler := ping.NewHandler(app, service)

    // Create a service level router
    router := app.Router.Methods(http.MethodGet).PathPrefix("/ping").Subrouter()

    // Register our service level router
    router.HandleFunc("/", handler.Handle).Name("ping:handle")
}
</code></pre>

<p>So, what we have done here is create a service, which we will see next. We then create our request handler, a service level sub router restructing this to a certain part prefix, and only accepting certain HTTP methods. We then define our first route of: <strong>/ping/</strong></p>

<p>Our service is a simple gateway to a Repository. In this specific example it wouldn't be needed as there is no real data that needs retrieving - but I will set it up as an example so that the concept is understood.</p>

<pre><code class="language-go">// pkg/domain/ping/service.go
package ping

import (
    "github.com/JustSteveKing/go-rest-api/pkg/infrastructure/factories"
    "net/http"
    "sync"
    "time"
)

// Service is the gateway to the Repository that is used to access data
type Service struct {
    Repository *PingRepository
}

// NewService will build and return a new Service
func NewService(app *factories.Application) *Service {
    return &amp;Service{
        Repository: NewRepository(app)
    }
}
</code></pre>

<p>So what we are doing here is simply creating a new service, with an implementation of a specific repositoy. This could be swapped out for a different repository at any time as and when required. I won't go too far down this route - maybe I will do a second blog post about bits I have skipped over here.</p>

<p>Routing in GoLang is nice, it's clean and it makes sense. I have build 2 go modules for this next part:</p>

<ul>
<li><a href="https://github.com/JustSteveKing/go-api-problem">Go API Problem</a> - for when you want consistent API error responses.</li>
<li><a href="https://github.com/JustSteveKing/go-http-response">Go HTTP Response</a> - for building API responses in a very specific format.</li>
</ul>

<p>To start with let's look at the first part, creating a handler</p>

<pre><code class="language-go">// pkg/domain/ping/endpoints.go
package ping

import(
    "github.com/JustSteveKing/go-rest-api/pkg/infrastructure/factories"
)

// Handler is the http.Handler for this service
type Handler struct {
    App *factories.Application
    Service *Service
}

// NewHandler will create a new Handler to handle any requests
func NewHandler(app *factories.Application, service *Service) *Handler {
    return &amp;Handler{
        App: app,
        Service: service,
    }
}
</code></pre>

<p>Here we are creating a new http.Handler and passing in both our Application and our specific Service for this Domain. What this allows us to do, is in each route, access our repository through the passed in service to our handler, alternatively you could also access the general application that is also being passed in - should you need to access configuration or any other struct or interface that you add to it.</p>

<p>Now only actually handling a route. This is a typical approach to handling requests in GoLang in most of the router modules available, but this is what I like to do:</p>

<pre><code class="language-go">// pkg/domain/ping/endpoints.go

/** The other code from above has been omitted here **/

// Handle will handle the /ping route in our application
func (handler *Handler) Handle(response http.ResponseWritter, request *http.Request) {
    // Log the request - add any useful information you want here
    handler.App.Logger.Info("Route Dispatched. Ping service triggered.")

    data, err := doSomthingCool()
    if err != nil {
        responseFactory.Send(
        response,
        http.StatusBadRequest,
        &amp;problem.APIProblem{
            Title:  "Error Message",
            Detail: "Detail on the error",
            Status: strconv.Itoa(http.StatusBadRequest),
            Code:   "ERROR-001-001",
        },
        handler.App.Config.HTTP.Problem,
        )

        return
    }

    responseFactory.Send(
        response,
        http.StatusOK,
        &amp;Response{
        Message: "Ping Service Online",
        },
        handler.App.Config.HTTP.Content,
    )

    return
}
</code></pre>

<p>So now we have some content being returned through our API. It isn't anthing exciting - a simple health check endpoint. However, what this is showing you is an easy to use pattern. When we first hit our endpoint, we log that request - in any way you want to, do any logical processing through the service into the repository that you might need to do, then build up a response and send it back. Sending a response here what we do is pass through the response writter from the current request, pass through the relevant HTTP status code, any sort of interface to be marshalled into an encoding, and we pass through the content type we want to send across. I like to keep the content type in configuration so that I have an application standard response content type (usually <strong>application/vnd.api+json</strong>) I also keep this very similar to any error responses (usually <strong>application/problem+json</strong>).</p>

<p>For now that is all I will be going through, I believe it is a general introduction into REST APIs in GoLang showing how I have approached certain problems and what I have done to make extending and scaling a little easier.</p>

<p>I'd love some feedback, or even recommendations! You can reach out to me on twitter at <strong>@JustSteveKing</strong> where I am always happy to take some constructive feedback. This will eventually be pushed up to GitHub also (same handle as twitter) so please feel free to follow me on there also, if you would like to see the finished code.</p>
                </div>
            </div>
            <footer class="text-sm font-medium leading-5 divide-y divide-gray-200 xl:col-start-1 xl:row-start-2">
                <div class="space-y-8 py-8">
                    <div>
                        <h2 class="text-xs tracking-wide uppercase">
                            Tags
                        </h2>
                        <div class="space-x-2 flex flex-wrap">
                                                             <a
    class="cursor-pointer hover:underline text-indigo-500 dark:text-indigo-200 hover:text-indigo-800 dark:hover:text-indigo-50" href="/blog/tags/golang" title="View articles in golang"
    href="/blog/tags/golang" title="View articles in golang"
>
    golang
</a> 
                                                             <a
    class="cursor-pointer hover:underline text-indigo-500 dark:text-indigo-200 hover:text-indigo-800 dark:hover:text-indigo-50" href="/blog/tags/api" title="View articles in api"
    href="/blog/tags/api" title="View articles in api"
>
    api
</a> 
                                                             <a
    class="cursor-pointer hover:underline text-indigo-500 dark:text-indigo-200 hover:text-indigo-800 dark:hover:text-indigo-50" href="/blog/tags/rest" title="View articles in rest"
    href="/blog/tags/rest" title="View articles in rest"
>
    rest
</a> 
                                                             <a
    class="cursor-pointer hover:underline text-indigo-500 dark:text-indigo-200 hover:text-indigo-800 dark:hover:text-indigo-50" href="/blog/tags/tutorial" title="View articles in tutorial"
    href="/blog/tags/tutorial" title="View articles in tutorial"
>
    tutorial
</a> 
                                                    </div>
                    </div>
                </div>
                <div class="space-y-8 py-8">
                    <div>
                        <h2 class="text-xs tracking-wide uppercase">
                            Reading Time
                        </h2>
                        <div class="space-x-2 flex flex-wrap">
                            <p>17 min read</p>
                        </div>
                    </div>
                </div>
                <div class="pt-8">
                    <a class="text-teal-500 hover:text-teal-600" href="/">
                        ‚Üê Back to the blog
                    </a>
                </div>
            </footer>
        </div>
        </article>
    </main>
        
         <footer>
    <div class="max-w-7xl mx-auto py-12 px-4 overflow-hidden sm:px-6 lg:px-8">
        <nav class="-mx-5 -my-2 flex flex-wrap justify-center" aria-label="Footer">
                            <div class="px-5 py-2 uppercase">
                     <a
    class="cursor-pointer text-gray-600 dark:text-gray-200 hover:text-gray-800 dark:hover:text-gray-50" title="Return Home" href="/"
    title="Return Home" href="/"
>
    Home
</a> 
                </div>
                            <div class="px-5 py-2 uppercase">
                     <a
    class="cursor-pointer text-gray-600 dark:text-gray-200 hover:text-gray-800 dark:hover:text-gray-50" title="Recent Articles" href="/blog"
    title="Recent Articles" href="/blog"
>
    Articles
</a> 
                </div>
                            <div class="px-5 py-2 uppercase">
                     <a
    class="cursor-pointer text-gray-600 dark:text-gray-200 hover:text-gray-800 dark:hover:text-gray-50" title="Open Source packages I have made" href="/open-source"
    title="Open Source packages I have made" href="/open-source"
>
    Open Source
</a> 
                </div>
                            <div class="px-5 py-2 uppercase">
                     <a
    class="cursor-pointer text-gray-600 dark:text-gray-200 hover:text-gray-800 dark:hover:text-gray-50" title="Subscribe to my RSS feed" href="/feed.xml"
    title="Subscribe to my RSS feed" href="/feed.xml"
>
    RSS Feed
</a> 
                </div>
                    </nav>
        <div class="mt-8 flex justify-center space-x-6">

             <a
    class="cursor-pointer text-gray-400 hover:text-linkedin" title="Visit me on LinkedIn" href="https://www.linkedin.com/in/steve-mcdougall/" onclick="window.fathom.trackGoal('C6E6URYJ', 0);"
    title="Visit me on LinkedIn" href="https://www.linkedin.com/in/steve-mcdougall/" class="hover:text-linkedin" onclick="window.fathom.trackGoal('C6E6URYJ', 0);"
    target="__blank"
    rel="noopener nofollow"
>
    <span class="sr-only">LinkedIn</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                </svg>
</a> 

             <a
    class="cursor-pointer text-gray-400 hover:text-twitter" title="Visit me on twitter" href="https://twitter.com/JustSteveKing" onclick="window.fathom.trackGoal('CZEGD7I0', 0);"
    title="Visit me on twitter" href="https://twitter.com/JustSteveKing" class="hover:text-twitter" onclick="window.fathom.trackGoal('CZEGD7I0', 0);"
    target="__blank"
    rel="noopener nofollow"
>
    <span class="sr-only">twitter</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/>
                </svg>
</a> 

             <a
    class="cursor-pointer text-gray-400 hover:text-github dark:hover:text-white" title="Visit me on GitHub" href="https://github.com/JustSteveKing" onclick="window.fathom.trackGoal('Q0HFSPVT', 0);"
    title="Visit me on GitHub" href="https://github.com/JustSteveKing" class="hover:text-github dark:hover:text-white" onclick="window.fathom.trackGoal('Q0HFSPVT', 0);"
    target="__blank"
    rel="noopener nofollow"
>
    <span class="sr-only">GitHub</span>
                <svg class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
                </svg>
</a> 

             <a
    class="cursor-pointer text-gray-400 hover:text-discord" title="Visit me on Discord" href="https://discordapp.com/users/533726823201243137" onclick="window.fathom.trackGoal('6TDA1OH6', 0);"
    title="Visit me on Discord" href="https://discordapp.com/users/533726823201243137" class="hover:text-discord" onclick="window.fathom.trackGoal('6TDA1OH6', 0);"
    target="__blank"
    rel="noopener nofollow"
>
    <span class="sr-only">Discord</span>
                <svg class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M20.317 4.37a19.791 19.791 0 00-4.885-1.515.074.074 0 00-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 00-5.487 0 12.64 12.64 0 00-.617-1.25.077.077 0 00-.079-.037A19.736 19.736 0 003.677 4.37a.07.07 0 00-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 00.031.057 19.9 19.9 0 005.993 3.03.078.078 0 00.084-.028c.462-.63.874-1.295 1.226-1.994a.076.076 0 00-.041-.106 13.107 13.107 0 01-1.872-.892.077.077 0 01-.008-.128 10.2 10.2 0 00.372-.292.074.074 0 01.077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 01.078.01c.12.098.246.198.373.292a.077.077 0 01-.006.127 12.299 12.299 0 01-1.873.892.077.077 0 00-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 00.084.028 19.839 19.839 0 006.002-3.03.077.077 0 00.032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 00-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z"/>
                </svg>
</a> 

             <a
    class="cursor-pointer text-gray-400 hover:text-telegram" title="Visit me on telegram" href="https://t.me/JustSteveKing" onclick="window.fathom.trackGoal('O0QXMHGN', 0);"
    title="Visit me on telegram" href="https://t.me/JustSteveKing" class="hover:text-telegram" onclick="window.fathom.trackGoal('O0QXMHGN', 0);"
    target="__blank"
    rel="noopener nofollow"
>
    <span class="sr-only">telegram</span>
                <svg class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M11.944 0A12 12 0 000 12a12 12 0 0012 12 12 12 0 0012-12A12 12 0 0012 0a12 12 0 00-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 01.171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/>
                </svg>
</a> 

        </div>
        <p class="mt-8 text-center text-base text-gray-400">
            &copy; 2021 Steve McDougall. All rights reserved.
        </p>
    </div>
</footer> 

    </body>
</html>
